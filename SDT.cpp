//
// Created by prwang on 6/30/2018.
#include <unordered_map>
#include "SDT.h"

//(bb1, var) -> var_t  (bb2, var) -> var_f
/*
 读入控制流图，最终play with数据流图*
 哪些节点是翻译生成的，哪些节点是postfix生成的？
 最开始预想的不变式是所有的节点都翻译生成。
 第一个例外是块外引用条件的变量，要加上区间的限制
 第二个例外是整数类型的小于语义，实际上是a <= b - 1


 */
void function_postfix()
{
  /* 每解析一个函数，就调用一次。那么就不需要搞很多env了
   * 并且这里给parse_postfix 留出余地。
   *1. 点已经建好了，现在需要连边，
   *基本的情况：同一变量的定义连到使用
   *附加的情况：考虑条件跳转的影响，在边上插入区间交 节点。
   * 一个定义，多个使用
   *所以需要枚举所有的使用(有一点二度点也没关系）。
   *  1.  函数内的使用，从每个点出发，看看它的入边
   *  2.  查redirection里面如果有，那连到redirection，否则连到自己
   *  3. 那么我需要知道，这个语句属于哪个基本块
   *  4. 这些用不着继承属性，直接存取全局变量就可以
   *  不如说它是一个redirection表，给一个自己在哪个块，我要哪个变量，则
   *  输出 1) 不存在，则可以安全地直接连过去 2)
   *
   *  如果函数调用不解析的话，那么图是不连通的。最后做强连通分量、缩点的时候应该
   *  边是什么意思？从定义指向使用。
   *  这个也不对，我拓扑排序排出来应该是每一个函数的求值顺序，那么应该从函数的参数开始
   *
   *
   */
}
/*
 * 我需要根据函数名字，查到它的哪些变量是使用了参数，然后去patch这些地方。
 * 一个函数被调用多次，我还是得复制它，调用了多少遍，就需要复制多少遍
 * 显然，我们应该以函数为单位进行解析，那么scc就不能用全局变量了，不一定
 * scc是静态的信息，当然可以逐个函数都做完
 * 缩点拓扑排序都可以静态做，最后输出一个求值顺序
 * 什么是动态信息？那就是每个节点的output.
 * 每次eval一个节点的时候需要读这个output.
 * output可以放在节点里面啊。没有递归那么
 *
 *
 *
 */
void parse_postfix()
{

}

//

